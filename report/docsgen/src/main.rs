//
// We use the strum crate with AsRefStr derive macro to be able to get the enum variant name by event.as_ref() on the Event enum for example
use std::{
    ffi::OsStr,
    fs::{read, write},
    path::PathBuf,
    process::Command,
    time::SystemTime,
};

use anstyle::Color;
use anstyle_svg::Term;
use chrono::{DateTime, Utc};
use colored::Colorize;
use dy::{
    parser::tokenize_into_lines,
    semantic::{Block, build_blocks_tree},
    spec::ValidDYSpec,
};
use plx_core::live::protocol::{
    Action, CheckStatus, ClientNum, Event, ExoCheckResult, ForwardedFile, ForwardedResult,
    LiveProtocolError, Session, SessionStats,
};
use plx_dy::{course::COURSE_SPEC, exo::EXO_SPEC, skill::SKILLS_SPEC};
use walkdir::WalkDir;

const PLANTUML_SERVER_URL: &str = "http://localhost:5076";
const PLANTUML_FILE_EXT: &str = "puml";
const PLANTUML_EXPORT_FORMAT: &str = "svg";

/// Send
/// The shell equivalent to this request is
/// `cat $schema | curl --silent --show-error --fail --data-binary @- "$PUML_SERVER/$format/" --output - >$image_name`
fn export_plantuml_diagrams() -> Result<(), Box<dyn std::error::Error>> {
    println!(
        "{}",
        format!(
            "Exporting PlantUML diagrams in {}",
            PLANTUML_EXPORT_FORMAT.to_uppercase()
        )
        .green()
    );
    let puml_paths: Vec<PathBuf> = WalkDir::new("../")
        .into_iter()
        .filter_entry(|entry| {
            // Skip all ignored folders and folder starting with a dot
            entry.file_type().is_dir()
                || entry.path().extension() == Some(OsStr::new(PLANTUML_FILE_EXT))
        })
        .filter_map(Result::ok)
        .filter(|e| e.file_type().is_file())
        .map(|e| e.into_path())
        .collect();

    if puml_paths.is_empty() {
        println!("No .{PLANTUML_FILE_EXT} file found in report folder");
    }

    for file in puml_paths {
        let image_file = file.with_extension(PLANTUML_EXPORT_FORMAT);
        println!("Exporting {file:?}");
        let content = read(&file).expect("File has been found by walkdir and should still exist");
        let client = reqwest::blocking::Client::new();
        let res = client
            .post(format!("{PLANTUML_SERVER_URL}/{PLANTUML_EXPORT_FORMAT}"))
            // This header is necessary to avoid french accents to get transformed in weird ways
            .header("Content-Type", "text/plain; charset=utf-8")
            .body(content)
            .send()?;
        let image = res.bytes().expect("Couldn't get PlantUML image back");
        write(image_file, image)?;
    }
    Ok(())
}

fn get_destination() -> PathBuf {
    PathBuf::from("../protocol/messages/")
}
// Filename and caption
type FileInclude = (String, String);
fn save_protocol_message<T>(
    msg: T,
    files: &mut Vec<FileInclude>,
    enum_name: &str,
    variant_name: &str,
) where
    T: serde::Serialize,
{
    save_protocol_message_with_filename_and_caption(
        format!("{enum_name}-{variant_name}.json"),
        format!("Message `{enum_name}::{variant_name}`"),
        msg,
        files,
    );
}

fn save_protocol_message_with_filename_and_caption<T>(
    filename: String,
    caption: String,
    msg: T,
    files: &mut Vec<FileInclude>,
) where
    T: serde::Serialize,
{
    // Note: this code is a bit dirty, it was made to make it work and should be rewritten if
    // needed to be changed...
    let destination = get_destination();
    // The formatting generated by strum_macros::Display is the name of the enum's variant !
    let first_file_destination = destination.join(&filename);
    let mut file_destination = first_file_destination.clone();
    // If already, exists, add a number after it
    let mut i = 2;
    while file_destination.exists() {
        // Generate the next -i file !
        file_destination = destination.join(format!(
            "{}-{}.json",
            file_destination
                .file_stem()
                .unwrap()
                .to_str()
                .unwrap()
                .split('-')
                .take(2) // Take the first two parts (../path/Action-SendResult)
                .collect::<Vec<_>>()
                .join("-"),
            i
        ));

        i += 1;
    }
    // Copy the existing file !
    if i == 3 {
        let new_name_first_file = destination.join(format!(
            "{}-{}.json",
            first_file_destination
                .file_stem()
                .unwrap()
                .to_str()
                .unwrap(),
            1
        ));
        std::fs::copy(&first_file_destination, &new_name_first_file).unwrap();
    }
    files.push((file_destination.to_str().unwrap().to_string(), caption));
    let content = serde_json::to_string_pretty(&msg).unwrap();
    write(&file_destination, &content).unwrap();
    println!("Saved {file_destination:?}");
}

fn export_protocol_messages() {
    println!("{}", "Exporting protocol messages as JSON".green());
    let mut all_json_files: Vec<FileInclude> = Vec::new();
    let events = [
        Event::SessionStopped,
        Event::SessionJoined(ClientNum(4)),
        Event::SessionLeaved,
        Event::SessionsList(vec![
            Session {
                name: "PRG2 Jack".to_string(),
                group_id: "https://github.com/prg2/prg2.git".to_string(),
            },
            Session {
                name: "PRG2 Alissa".to_string(),
                group_id: "https://github.com/prg2/prg2.git".to_string(),
            },
        ]),
        Event::Stats(SessionStats {
            followers_count: 32,
            leaders_count: 2,
        }),
        Event::ExoSwitched {
            path: "intro/salue-moi".to_string(),
        },
        Event::ServerStopped,
        Event::ForwardFile {
            client_num: ClientNum(23),
            file: ForwardedFile {
                path: "main.c".to_string(),
                content: r#"
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("hello world!\n");
    return 0;
}

"#
                .to_string(),
                time: DateTime::<Utc>::from(SystemTime::now()),
            },
        },
        Event::ForwardResult {
            client_num: ClientNum(12),
            result: ForwardedResult {
                check_result: ExoCheckResult {
                    state: CheckStatus::Passed,
                    index: 0,
                },
                time: DateTime::<Utc>::from(SystemTime::now()),
            },
        },
    ];

    let actions = [
        Action::StartSession {
            name: "PRG2 Jack".to_string(),
            group_id: "https://github.com/prg2/prg2.git".to_string(),
        },
        Action::StopSession,
        Action::GetSessions {
            group_id: "https://github.com/prg2/prg2.git".to_string(),
        },
        Action::JoinSession {
            name: "PRG2 Alissa".to_string(),
            group_id: "https://github.com/prg2/prg2.git".to_string(),
        },
        Action::LeaveSession,
        Action::SendFile {
            path: "main.c".to_string(),
            content: r#"
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("hello world!\n");
    return 0;
}
"#
            .to_string(),
        },
        Action::SendResult {
            check_result: ExoCheckResult {
                state: CheckStatus::Passed,
                index: 3,
            },
        },
        Action::SendResult {
            check_result: ExoCheckResult {
                state: CheckStatus::BuildFailed(
                    "main.c: In function ‘main’:\nmain.c:4:5: error: ‘a’ undeclared".to_string(),
                ),
                index: 0,
            },
        },
        Action::SendResult {
            check_result: ExoCheckResult {
                state: CheckStatus::CheckFailed("Hello Doe !".to_string()),
                index: 1,
            },
        },
        Action::SendResult {
            check_result: ExoCheckResult {
                state: CheckStatus::RunFailed("Hello\nsegfault".to_string()), // TODO: fix that
                index: 1,
            },
        },
        Action::SwitchExo {
            path: "structs/hello-dog".to_string(),
        },
    ];

    for action in actions {
        save_protocol_message(&action, &mut all_json_files, "Action", action.as_ref());
    }
    for event in events.as_slice() {
        save_protocol_message(event, &mut all_json_files, "Event", event.as_ref());
    }

    let errors_event = [
        LiveProtocolError::FailedToStartSession(
            "There is already a session with the same group id and name combination.".to_string(),
        ),
        LiveProtocolError::FailedToJoinSession(
            "No session found with this name in this group id".to_string(),
        ),
        LiveProtocolError::FailedSendingWithoutSession,
        LiveProtocolError::FailedToLeaveSession,
        LiveProtocolError::SessionNotFound,
        LiveProtocolError::CannotJoinOtherSession,
        LiveProtocolError::ForbiddenSessionStop,
        LiveProtocolError::ActionOnlyForLeader("switch of exo".to_string()),
    ];
    for (idx, error) in errors_event.into_iter().enumerate() {
        save_protocol_message_with_filename_and_caption(
            format!("Event-Error-{idx}.json"),
            format!(
                "Message `Event::Error(LiveProtocolError::{})`",
                error.as_ref()
            ),
            Event::Error(error),
            &mut all_json_files,
        );
    }

    // Generate filename and 3 types of caption
    // 1. caption = Message `Action::StopSession`
    // 2. caption = Message `Event::SessionStarted`
    // 3. caption = Message `Event::Error(LiveProtocolError::ForbiddenSessionStop)`
    let mut typst_lines =
        "// Note: this typst file is auto generated by docsgen (see report/docsgen)\n".to_string()
            + "// DO NOT edit manually, changes will be overriden at next run.\n\n";
    for (filename, caption) in all_json_files {
        typst_lines.push_str(
            format!(
                r#"#figure(raw(block: true, lang: "json", read("{filename}")), caption: [{caption}])"#
            )
            .as_str(),
        );
        typst_lines.push('\n');
    }
    write("../protocol/messages/messages.typ", typst_lines).expect("Couldn't save messages.typ");
    println!("{}", "Saved messages.typ !\n".blue());
}

/// Given some DY spec and texts, export the different state of each step to document them
fn export_parser_steps() {
    let base_path = "../syntax";
    let dy_paths: Vec<PathBuf> = WalkDir::new(base_path)
        .follow_links(true)
        .into_iter()
        .filter_entry(|entry| {
            entry.file_type().is_dir() || entry.path().extension() == Some(OsStr::new("dy"))
        })
        .filter_map(Result::ok)
        .filter(|e| e.file_type().is_file())
        .map(|e| e.into_path())
        .collect();

    for file in dy_paths {
        // Export the highligthed code !
        let mut output = file.clone();
        output.set_extension("svg");
        let output_path = file.parent().unwrap().join(output.file_name().unwrap());
        let mut cmd = Command::new("tree-sitter");
        cmd.args(vec!["highlight", file.to_str().unwrap()])
            .current_dir(base_path)
            .env("CLICOLOR_FORCE", "true");

        export_command_output_to_svg(&mut cmd, &output_path, None);
        println!(
            "#figure( image(\"{}\", width: 100%), caption: [TODO `{}`],)",
            output_path.to_str().unwrap(),
            file.file_name().unwrap().to_str().unwrap()
        );

        // Export the "plx parse" version
        let mut output_path = file.clone();
        output_path.set_file_name(format!(
            "{}-parsed.svg",
            file.file_stem().unwrap().to_string_lossy()
        ));
        let short_relative_filename = format!(
            "{}/{}",
            file.parent()
                .unwrap()
                .file_name()
                .unwrap()
                .to_str()
                .unwrap(),
            file.file_name().unwrap().to_str().unwrap()
        );
        let mut cmd = Command::new("plx");
        cmd.args(vec!["parse", &short_relative_filename])
            .current_dir(base_path)
            .env("CLICOLOR_FORCE", "true");

        export_command_output_to_svg(
            &mut cmd,
            &output_path,
            Some(format!(
                "{}",
                format!("plx parse {short_relative_filename}").bold()
            )),
        );

        println!(
            "#figure( image(\"{}\", width: 100%), caption: [TODO],)",
            output_path.to_str().unwrap(),
        );
    }
}

fn export_command_output_to_svg(
    cmd: &mut Command,
    svg_filename: &PathBuf,
    included_command: Option<String>,
) {
    let result = cmd.output().unwrap();
    // TODO: that's a bit cheating but stderr come first if parse is successful
    let mut ansi_output = String::from_utf8(result.stderr).unwrap();
    ansi_output.push_str(&String::from_utf8(result.stdout).unwrap());
    let mut start = match included_command {
        Some(command) => format!("> {command}\n"),
        None => String::default(),
    };
    start.push_str(ansi_output.trim());
    let svg = Term::new()
        .min_width_px(700)
        .fg_color(Color::Ansi(anstyle::AnsiColor::Black))
        .background(false)
        .render_svg(&start);
    // svg.replace("", to)

    std::fs::write(svg_filename, svg).unwrap();
}

struct GraphTree<'a> {
    keys: Vec<GraphKey<'a>>,
}

impl<'a> GraphTree<'a> {
    fn export(&self, file: &PathBuf) {
        let mut schema = "digraph G {
rankdir=LR;\n"
            .to_string();
        schema.push_str(
            &self
                .keys
                .iter()
                .map(|k: &GraphKey<'_>| k.describe())
                .collect::<Vec<String>>()
                .join("\n"),
        );
        schema.push_str("\n}");

        write("target/test.dot", schema).unwrap();
        let mut binding = Command::new("dot");
        let cmd = binding.args(vec![
            "-Tsvg",
            "target/test.dot",
            "-o",
            file.to_str().unwrap(),
        ]);
        dbg!(String::from_utf8(cmd.output().unwrap().stdout).unwrap());
        dbg!(String::from_utf8(cmd.output().unwrap().stderr).unwrap());
        assert_eq!(cmd.output().unwrap().status.success(), true);
        println!("Saved {file:?}");
    }

    fn from_spec(specs: &dy::spec::DYSpec<'a>) -> Self {
        let mut graph = GraphTree { keys: vec![] };
        graph.keys = specs
            .iter()
            .map(|s| GraphKey {
                key: s.id.to_string(),
                title: s.id.to_string(),
                keys: vec![
                    ("ValueType", format!("{:?}", s.vt)),
                    ("Once", s.once.to_string()),
                    ("Required", s.required.to_string()),
                ],
                subtree: GraphTree::from_spec(s.subkeys),
            })
            .collect();
        graph
    }

    fn from_blocks(blocks: &Vec<Block<'a>>) -> Self {
        let mut graph = GraphTree { keys: vec![] };
        graph.keys = blocks
            .iter()
            .map(|b| GraphKey {
                key: b.range.start.line.to_string(),
                title: b.key.id.to_string(),
                keys: vec![
                    (
                        "text",
                        format!("\"{}\"", break_by_words(&b.text.join("\\n<br/>"), 5).trim()),
                    ),
                    ("key", b.key.id.to_string()),
                    (
                        "range",
                        format!(
                            "{}:{}-{}:{}",
                            b.range.start.line,
                            b.range.start.character,
                            b.range.end.line,
                            b.range.end.character,
                        ),
                    ),
                ],
                subtree: GraphTree::from_blocks(&b.subblocks),
            })
            .collect();
        graph
    }
}

struct GraphKey<'a> {
    key: String,
    title: String,
    keys: Vec<(&'a str, String)>,
    subtree: GraphTree<'a>,
}

fn break_by_words(sentence: &str, count: usize) -> String {
    let words: Vec<&str> = sentence.split_whitespace().collect();
    let mut result = String::new();
    for chunk in words.chunks(count) {
        if !result.is_empty() {
            result.push_str("<br/>");
        }
        result.push_str(&chunk.join(" "));
    }
    result
}

impl<'a> GraphKey<'a> {
    fn describe(&self) -> String {
        let key = &self.key;
        // todo: include desc ? how to split in small pieces ??
        let format = format!(
            r#"{key} [shape=box,
style="rounded,filled"
fillcolor=" #f5f5f5"
FIXEDSIZE="FALSE"
    label=<<B>{}</B><BR/><FONT POINT-SIZE="12">{}</FONT>
    >, margin="0.5,0.2"];
{}
{}
"#,
            self.title,
            // splitted_desc,
            self.keys
                .iter()
                .map(|(k, v)| format!("{k}: {v}"))
                .collect::<Vec<String>>()
                .join("<br/>"),
            self.subtree
                .keys
                .iter()
                .map(|k| format!("{key} -> {}", k.key))
                .collect::<Vec<String>>()
                .join("\n"),
            self.subtree
                .keys
                .iter()
                .map(|k| k.describe())
                .collect::<Vec<String>>()
                .join("\n"),
        );
        format
    }
}

fn exports_plx_dy_specs() {
    let tree = GraphTree::from_spec(COURSE_SPEC);
    tree.export(&PathBuf::from("../syntax/specs/course.spec.svg"));

    let tree = GraphTree::from_spec(SKILLS_SPEC);
    tree.export(&PathBuf::from("../syntax/specs/skills.spec.svg"));

    let tree = GraphTree::from_spec(EXO_SPEC);
    tree.export(&PathBuf::from("../syntax/specs/exo.spec.svg"));
}

fn exports_dy_blocks() {
    let exo = "exo Salue-moi
Un petit programme qui te salue avec ton nom complet.

check Il est possible d'être salué avec son nom complet
see Quel est ton prénom ?
type John
see Salut John, quel est ton nom de famille ?
type Doe
see Passe une belle journée John Doe !
exit 0
";
    let validspec = &ValidDYSpec::new(EXO_SPEC).unwrap();
    let lines = tokenize_into_lines(validspec, exo);
    let blocks = build_blocks_tree(validspec, lines);

    let tree = GraphTree::from_blocks(&blocks.0);
    tree.export(&PathBuf::from("../syntax/blocks/salue-moi-blocks.svg"));
}

fn main() {
    // Trash existing files under messages folder to avoid old Message files
    let dest_folder = get_destination();
    if dest_folder.exists() {
        remove_dir_all(&dest_folder).unwrap();
    }
    let _ = create_dir(&dest_folder);
    exports_plx_dy_specs();
    export_parser_steps();
    export_protocol_messages();
    export_plantuml_diagrams().unwrap();
    exports_dy_blocks();

    println!(
        "\nNote: remember to manually update LiveProtocolError list of errors if you added one manually !"
    );
    println!("Note: remember to add other messages instances if new ones are created !");
}
