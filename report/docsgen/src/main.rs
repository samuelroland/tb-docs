// We use the strum crate with AsRefStr derive macro to be able to get the enum variant name by event.as_ref() on the Event enum for example
use std::{
    ffi::OsStr,
    fs::{read, write},
    path::PathBuf,
    time::SystemTime,
};

use chrono::{DateTime, Utc};
use colored::Colorize;
use plx::live::{
    msg::{
        Action, CheckStatus, ClientNum, Event, ExoCheckResult, ForwardedFile, ForwardedResult,
        LiveProtocolError,
    },
    session::Session,
};
use walkdir::WalkDir;

const PLANTUML_SERVER_URL: &str = "http://localhost:5076";
const PLANTUML_FILE_EXT: &str = "puml";
const PLANTUML_EXPORT_FORMAT: &str = "svg";

/// Send
/// The shell equivalent to this request is
/// `cat $schema | curl --silent --show-error --fail --data-binary @- "$PUML_SERVER/$format/" --output - >$image_name`
fn export_plantuml_diagrams() -> Result<(), Box<dyn std::error::Error>> {
    println!(
        "{}",
        format!(
            "Exporting PlantUML diagrams in {}",
            PLANTUML_EXPORT_FORMAT.to_uppercase()
        )
        .green()
    );
    let puml_paths: Vec<PathBuf> = WalkDir::new("../")
        .into_iter()
        .filter_entry(|entry| {
            // Skip all ignored folders and folder starting with a dot
            entry.file_type().is_dir()
                || entry.path().extension() == Some(OsStr::new(PLANTUML_FILE_EXT))
        })
        .filter_map(Result::ok)
        .filter(|e| e.file_type().is_file())
        .map(|e| e.into_path())
        .collect();

    if puml_paths.is_empty() {
        println!("No .{PLANTUML_FILE_EXT} file found in report folder");
    }

    for file in puml_paths {
        let image_file = file.with_extension(PLANTUML_EXPORT_FORMAT);
        println!("Exporting {file:?}");
        let content = read(&file).expect("File has been found by walkdir and should still exist");
        let client = reqwest::blocking::Client::new();
        let res = client
            .post(format!("{PLANTUML_SERVER_URL}/{PLANTUML_EXPORT_FORMAT}"))
            // This header is necessary to avoid french accents to get transformed in weird ways
            .header("Content-Type", "text/plain; charset=utf-8")
            .body(content)
            .send()?;
        let image = res.bytes().expect("Couldn't get PlantUML image back");
        write(image_file, image)?;
    }
    Ok(())
}

// Filename and caption
type FileInclude = (String, String);
fn save_protocol_message<T>(
    msg: T,
    files: &mut Vec<FileInclude>,
    enum_name: &str,
    variant_name: &str,
) where
    T: serde::Serialize,
{
    save_protocol_message_with_filename_and_caption(
        format!("{enum_name}-{variant_name}.json"),
        format!("Message `{enum_name}::{variant_name}`"),
        msg,
        files,
    );
}

fn save_protocol_message_with_filename_and_caption<T>(
    filename: String,
    caption: String,
    msg: T,
    files: &mut Vec<FileInclude>,
) where
    T: serde::Serialize,
{
    let destination: PathBuf = PathBuf::from("../protocol/messages/");
    // The formatting generated by strum_macros::Display is the name of the enum's variant !
    let file_destination = destination.join(&filename);
    files.push((filename, caption));
    let content = serde_json::to_string_pretty(&msg).unwrap();
    write(&file_destination, &content).unwrap();
    println!("Saved {file_destination:?}");
}

fn export_protocol_messages() {
    println!("{}", "Exporting protocol messages as JSON".green());
    let mut all_json_files: Vec<FileInclude> = Vec::new();
    let events = [
        Event::SessionStopped,
        Event::SessionJoined(ClientNum(4)),
        Event::SessionsList(vec![
            Session {
                name: "PRG2 Jack".to_string(),
                group_id: "https://github.com/prg2/prg2.git".to_string(),
            },
            Session {
                name: "PRG2 Alissa".to_string(),
                group_id: "https://github.com/prg2/prg2.git".to_string(),
            },
        ]),
        Event::Stats(plx::live::msg::SessionStats {
            followers_count: 32,
            leaders_count: 2,
        }),
        Event::ExoSwitched {
            path: "intro/salue-moi".to_string(),
        },
        Event::ForwardFile {
            client_num: ClientNum(23),
            file: ForwardedFile {
                path: "main.c".to_string(),
                content: r#"
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("hello world!\n");
    return 0;
}

"#
                .to_string(),
                time: DateTime::<Utc>::from(SystemTime::now()),
            },
        },
        Event::ForwardResult {
            client_num: ClientNum(12),
            result: ForwardedResult {
                check_result: ExoCheckResult {
                    state: CheckStatus::Passed,
                    index: 0,
                },
                time: DateTime::<Utc>::from(SystemTime::now()),
            },
        },
    ];

    let actions = [
        Action::StartSession {
            name: "PRG2 Jack".to_string(),
            group_id: "https://github.com/prg2/prg2.git".to_string(),
        },
        Action::StopSession,
        Action::GetSessions {
            group_id: "https://github.com/prg2/prg2.git".to_string(),
        },
        Action::JoinSession {
            name: "PRG2 Alissa".to_string(),
            group_id: "https://github.com/prg2/prg2.git".to_string(),
        },
        Action::LeaveSession,
        Action::SendFile {
            path: "main.c".to_string(),
            content: r#"
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("hello world!\n");
    return 0;
}

"#
            .to_string(),
        },
        Action::SendResult {
            check_result: ExoCheckResult {
                state: CheckStatus::Passed,
                index: 3,
            },
        },
        Action::SendResult {
            check_result: ExoCheckResult {
                state: CheckStatus::BuildFailed(
                    "main.c: In function ‘main’:\nmain.c:4:5: error: ‘a’ undeclared".to_string(),
                ),
                index: 0,
            },
        },
        Action::SendResult {
            check_result: ExoCheckResult {
                state: CheckStatus::CheckFailed("Hello Doe !".to_string()),
                index: 1,
            },
        },
        Action::SendResult {
            check_result: ExoCheckResult {
                state: CheckStatus::RunFailed("Hello\nsegfault".to_string()), // TODO: fix that
                index: 1,
            },
        },
        Action::ExoSwitch {
            path: "structs/hello-dog".to_string(),
        },
    ];

    for action in actions {
        save_protocol_message(&action, &mut all_json_files, "Action", action.as_ref());
    }
    for event in events.as_slice() {
        save_protocol_message(event, &mut all_json_files, "Event", event.as_ref());
    }

    let errors_event = [
        LiveProtocolError::FailedToStartSession(
            "There is already a session with the same group id and name combination.".to_string(),
        ),
        LiveProtocolError::FailedToJoinSession(
            "No session found with this name in this group id".to_string(),
        ),
        LiveProtocolError::FailedSendingWithoutSession,
        LiveProtocolError::FailedToLeaveSession,
        LiveProtocolError::SessionNotFound,
        LiveProtocolError::CannotJoinOtherSession,
        LiveProtocolError::ForbiddenSessionStop,
        LiveProtocolError::ActionOnlyForLeader("switch of exo".to_string()),
    ];
    for (idx, error) in errors_event.into_iter().enumerate() {
        save_protocol_message_with_filename_and_caption(
            format!("Event-Error-{idx}.json"),
            format!(
                "Message `Event::Error(LiveProtocolError::{})`",
                error.as_ref()
            ),
            Event::Error(error),
            &mut all_json_files,
        );
    }

    // Generate filename and 3 types of caption
    // 1. caption = Message `Action::StopSession`
    // 2. caption = Message `Event::SessionStarted`
    // 3. caption = Message `Event::Error(LiveProtocolError::ForbiddenSessionStop)`
    let mut typst_lines =
        "// Note: this typst file is auto generated by docsgen (see report/docsgen)\n".to_string()
            + "// DO NOT edit manually, changes will be overriden at next run.\n\n";
    for (filename, caption) in all_json_files {
        typst_lines.push_str(
            format!(
                r#"#figure(raw(block: true, lang: "json", read("{filename}")), caption: [{caption}])"#
            )
            .as_str(),
        );
        typst_lines.push('\n');
    }
    write("../protocol/messages/messages.typ", typst_lines).expect("Couldn't save messages.typ");
    println!("{}", "Saved messages.typ !\n".blue());
}

fn main() {
    export_protocol_messages();
    export_plantuml_diagrams().unwrap();

    println!(
        "\nNote: remember to manually update LiveProtocolError list of errors if you added one manually !"
    );
    println!("Note: remember to add other messages instances if new ones are created !");
}
